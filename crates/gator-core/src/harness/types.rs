//! Core types for the harness adapter interface.
//!
//! Defines `AgentHandle`, `AgentEvent`, and `MaterializedTask` -- the data
//! types that flow between the orchestrator and agent harness adapters.

use std::collections::HashMap;
use std::path::PathBuf;

use serde::{Deserialize, Serialize};
use tokio::process::ChildStdin;
use uuid::Uuid;

/// Handle to a running agent subprocess.
///
/// Returned by [`super::Harness::spawn`] and passed back into
/// [`super::Harness::events`], [`super::Harness::send`], etc.
///
/// The `stdin` field is wrapped in `Option<ChildStdin>` so it can be taken
/// once when the caller needs to write to the process. This avoids lifetime
/// issues with borrowing while still allowing the handle to be stored.
pub struct AgentHandle {
    /// OS process ID of the spawned agent.
    pub pid: u32,
    /// Writable end of the agent's stdin pipe.
    /// Wrapped in `Option` so it can be `.take()`-ed when needed.
    pub stdin: Option<ChildStdin>,
    /// The task this agent is working on.
    pub task_id: Uuid,
    /// Which attempt number (0-indexed) for this task.
    pub attempt: u32,
    /// Name of the harness that spawned this agent (e.g. "claude-code").
    pub harness_name: String,
}

// Manual Debug impl because ChildStdin does not implement Debug in a
// useful way and we want the rest of the fields visible.
impl std::fmt::Debug for AgentHandle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AgentHandle")
            .field("pid", &self.pid)
            .field("stdin", &self.stdin.as_ref().map(|_| "<ChildStdin>"))
            .field("task_id", &self.task_id)
            .field("attempt", &self.attempt)
            .field("harness_name", &self.harness_name)
            .finish()
    }
}

/// Events streamed from a running agent.
///
/// A harness adapter parses its agent's raw output (e.g. JSONL from
/// `claude --output-format stream-json`) and maps each relevant line
/// into one of these variants.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum AgentEvent {
    /// Agent produced a text message.
    Message {
        /// Role of the speaker (e.g. "assistant", "user").
        role: String,
        /// Text content.
        content: String,
    },

    /// Agent invoked a tool.
    ToolCall {
        /// Tool name (e.g. "Bash", "Read", "Edit").
        tool: String,
        /// Tool input payload.
        input: serde_json::Value,
    },

    /// A tool returned a result to the agent.
    ToolResult {
        /// Tool name.
        tool: String,
        /// Tool output payload.
        output: serde_json::Value,
    },

    /// Token usage accounting snapshot.
    TokenUsage {
        /// Tokens consumed from the prompt.
        input_tokens: u64,
        /// Tokens generated by the model.
        output_tokens: u64,
    },

    /// An error occurred in the agent or harness.
    Error {
        /// Human-readable error description.
        message: String,
    },

    /// The agent has finished (process exited).
    Completed,
}

/// A fully-resolved task description ready to hand to an agent.
///
/// This is the "materialized" view: all database lookups have already been
/// done, environment variables are populated (including the scoped token),
/// and the working directory is set to the agent's worktree.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaterializedTask {
    /// Database ID of the task.
    pub task_id: Uuid,
    /// Short, human-readable task name.
    pub name: String,
    /// Full task description (may be multi-line markdown).
    pub description: String,
    /// Shell commands the agent can run to check invariants
    /// (e.g. `["cargo build --workspace", "cargo test"]`).
    pub invariant_commands: Vec<String>,
    /// Absolute path to the git worktree where the agent should work.
    pub working_dir: PathBuf,
    /// Environment variables to inject into the agent's process,
    /// including `GATOR_AGENT_TOKEN`.
    pub env_vars: HashMap<String, String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn agent_event_serde_round_trip_message() {
        let event = AgentEvent::Message {
            role: "assistant".to_string(),
            content: "Hello".to_string(),
        };
        let json = serde_json::to_string(&event).unwrap();
        let back: AgentEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(event, back);
    }

    #[test]
    fn agent_event_serde_round_trip_tool_call() {
        let event = AgentEvent::ToolCall {
            tool: "Bash".to_string(),
            input: serde_json::json!({"command": "ls"}),
        };
        let json = serde_json::to_string(&event).unwrap();
        let back: AgentEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(event, back);
    }

    #[test]
    fn agent_event_serde_round_trip_tool_result() {
        let event = AgentEvent::ToolResult {
            tool: "Bash".to_string(),
            output: serde_json::json!({"stdout": "file.rs"}),
        };
        let json = serde_json::to_string(&event).unwrap();
        let back: AgentEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(event, back);
    }

    #[test]
    fn agent_event_serde_round_trip_token_usage() {
        let event = AgentEvent::TokenUsage {
            input_tokens: 100,
            output_tokens: 50,
        };
        let json = serde_json::to_string(&event).unwrap();
        let back: AgentEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(event, back);
    }

    #[test]
    fn agent_event_serde_round_trip_error() {
        let event = AgentEvent::Error {
            message: "something went wrong".to_string(),
        };
        let json = serde_json::to_string(&event).unwrap();
        let back: AgentEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(event, back);
    }

    #[test]
    fn agent_event_serde_round_trip_completed() {
        let event = AgentEvent::Completed;
        let json = serde_json::to_string(&event).unwrap();
        let back: AgentEvent = serde_json::from_str(&json).unwrap();
        assert_eq!(event, back);
    }

    #[test]
    fn materialized_task_serde_round_trip() {
        let task = MaterializedTask {
            task_id: Uuid::new_v4(),
            name: "test-task".to_string(),
            description: "Do something useful.".to_string(),
            invariant_commands: vec![
                "cargo build --workspace".to_string(),
                "cargo test".to_string(),
            ],
            working_dir: PathBuf::from("/tmp/worktree"),
            env_vars: HashMap::from([(
                "GATOR_AGENT_TOKEN".to_string(),
                "gator_at_abc_0_deadbeef".to_string(),
            )]),
        };
        let json = serde_json::to_string(&task).unwrap();
        let back: MaterializedTask = serde_json::from_str(&json).unwrap();
        assert_eq!(task.task_id, back.task_id);
        assert_eq!(task.name, back.name);
        assert_eq!(task.description, back.description);
        assert_eq!(task.invariant_commands, back.invariant_commands);
        assert_eq!(task.working_dir, back.working_dir);
        assert_eq!(task.env_vars, back.env_vars);
    }

    #[test]
    fn agent_handle_debug_does_not_panic() {
        let handle = AgentHandle {
            pid: 12345,
            stdin: None,
            task_id: Uuid::new_v4(),
            attempt: 0,
            harness_name: "test-harness".to_string(),
        };
        let debug_str = format!("{handle:?}");
        assert!(debug_str.contains("12345"));
        assert!(debug_str.contains("test-harness"));
    }
}
