//! `gator pr` command: create a GitHub PR from a completed plan.

use anyhow::{Context, Result, bail};
use sqlx::PgPool;

use gator_db::models::PlanStatus;
use gator_db::queries::agent_events;
use gator_db::queries::plans as plan_db;
use gator_db::queries::tasks as task_db;

/// Options for the PR command.
pub struct PrOptions {
    /// Create the PR as a draft.
    pub draft: bool,
    /// Override the base branch (defaults to plan's base_branch).
    pub base: Option<String>,
}

/// Run the PR command.
pub async fn run_pr(pool: &PgPool, plan_id_str: &str, options: &PrOptions) -> Result<()> {
    let plan_id = crate::resolve::resolve_plan_id(plan_id_str)?;

    let plan = plan_db::get_plan(pool, plan_id)
        .await?
        .with_context(|| format!("plan {plan_id} not found"))?;

    // Validate plan is completed.
    if plan.status != PlanStatus::Completed {
        bail!(
            "plan {} has status {}, expected completed. \
             Only completed plans can be turned into PRs.",
            plan_id,
            plan.status
        );
    }

    let tasks = task_db::list_tasks_for_plan(pool, plan_id).await?;
    let (input_tokens, output_tokens) =
        agent_events::get_token_usage_for_plan(pool, plan_id).await?;

    // Compute duration.
    let duration_str = match (plan.approved_at, plan.completed_at) {
        (Some(start), Some(end)) => {
            let secs = (end - start).num_seconds();
            let mins = secs / 60;
            let rem = secs % 60;
            format!("{mins}m {rem}s")
        }
        _ => "-".to_string(),
    };

    let body = build_pr_body(
        &plan.name,
        &tasks,
        input_tokens,
        output_tokens,
        &duration_str,
    );

    let base_branch = options.base.as_deref().unwrap_or(&plan.base_branch);

    // Build gh command.
    let mut args = vec![
        "pr".to_string(),
        "create".to_string(),
        "--title".to_string(),
        plan.name.clone(),
        "--body".to_string(),
        body,
        "--base".to_string(),
        base_branch.to_string(),
    ];

    if options.draft {
        args.push("--draft".to_string());
    }

    println!("Creating PR for plan: {} ({})", plan.name, plan.id);
    println!("  Base branch: {base_branch}");
    if options.draft {
        println!("  Mode: draft");
    }

    let output = std::process::Command::new("gh")
        .args(&args)
        .output()
        .context("failed to run `gh` -- is GitHub CLI installed?")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("gh pr create failed: {stderr}");
    }

    let pr_url = String::from_utf8_lossy(&output.stdout).trim().to_string();
    println!("\nPR created: {pr_url}");

    Ok(())
}

/// Build the PR body markdown from plan/task data.
///
/// This is a pure function for easy unit testing.
pub fn build_pr_body(
    plan_name: &str,
    tasks: &[gator_db::models::Task],
    input_tokens: i64,
    output_tokens: i64,
    duration: &str,
) -> String {
    let mut body = String::new();

    body.push_str("## Summary\n\n");
    body.push_str(&format!(
        "Automated PR from gator plan: **{}**\n\n",
        plan_name
    ));

    // Task table.
    body.push_str("## Tasks\n\n");
    body.push_str("| Task | Scope | Status | Attempts |\n");
    body.push_str("|------|-------|--------|----------|\n");

    for task in tasks {
        body.push_str(&format!(
            "| {} | {} | {} | {} |\n",
            task.name, task.scope_level, task.status, task.attempt
        ));
    }

    body.push('\n');

    // Token summary.
    let total_tokens = input_tokens + output_tokens;
    body.push_str("## Metrics\n\n");
    body.push_str(&format!("- **Duration:** {duration}\n"));
    body.push_str(&format!("- **Total tokens:** {total_tokens}\n"));
    body.push_str(&format!(
        "- **Token breakdown:** {input_tokens} input / {output_tokens} output\n"
    ));
    body.push_str(&format!(
        "- **Tasks:** {} total, {} passed\n",
        tasks.len(),
        tasks
            .iter()
            .filter(|t| t.status == gator_db::models::TaskStatus::Passed)
            .count()
    ));

    body.push_str("\n---\n");
    body.push_str("*Generated by [gator](https://github.com/gator-dev/gator)*\n");

    body
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use gator_db::models::{GatePolicy, ScopeLevel, Task, TaskStatus};
    use uuid::Uuid;

    fn mock_task(name: &str, scope: ScopeLevel, status: TaskStatus, attempt: i32) -> Task {
        Task {
            id: Uuid::new_v4(),
            plan_id: Uuid::new_v4(),
            name: name.to_string(),
            description: "test".to_string(),
            scope_level: scope,
            gate_policy: GatePolicy::Auto,
            retry_max: 3,
            status,
            assigned_harness: Some("claude-code".to_string()),
            requested_harness: None,
            worktree_path: Some("/tmp/wt".to_string()),
            attempt,
            created_at: Utc::now(),
            started_at: Some(Utc::now()),
            completed_at: Some(Utc::now()),
        }
    }

    #[test]
    fn build_pr_body_formats_correctly() {
        let tasks = vec![
            mock_task("implement-auth", ScopeLevel::Narrow, TaskStatus::Passed, 1),
            mock_task("add-tests", ScopeLevel::Medium, TaskStatus::Passed, 2),
            mock_task("update-docs", ScopeLevel::Broad, TaskStatus::Passed, 1),
        ];

        let body = build_pr_body("Add authentication", &tasks, 50000, 25000, "5m 30s");

        assert!(body.contains("Add authentication"));
        assert!(body.contains("implement-auth"));
        assert!(body.contains("add-tests"));
        assert!(body.contains("update-docs"));
        assert!(body.contains("75000")); // total tokens
        assert!(body.contains("50000 input"));
        assert!(body.contains("25000 output"));
        assert!(body.contains("5m 30s"));
        assert!(body.contains("3 total, 3 passed"));
    }

    #[test]
    fn build_pr_body_with_zero_tokens() {
        let tasks = vec![mock_task(
            "task-a",
            ScopeLevel::Narrow,
            TaskStatus::Passed,
            1,
        )];

        let body = build_pr_body("Empty plan", &tasks, 0, 0, "-");

        assert!(body.contains("Empty plan"));
        assert!(body.contains("**Total tokens:** 0"));
    }

    #[test]
    fn build_pr_body_contains_table_headers() {
        let tasks = vec![];
        let body = build_pr_body("Test", &tasks, 0, 0, "-");

        assert!(body.contains("| Task | Scope | Status | Attempts |"));
        assert!(body.contains("|------|-------|--------|----------|"));
    }
}
